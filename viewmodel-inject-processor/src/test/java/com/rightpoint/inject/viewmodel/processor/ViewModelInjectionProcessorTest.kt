package com.rightpoint.inject.viewmodel.processor

import com.google.common.truth.Truth.assertAbout
import com.google.testing.compile.JavaFileObjects
import com.google.testing.compile.JavaSourcesSubjectFactory.javaSources
import org.junit.Test

private const val GENERATED_TYPE = "javax.annotation.Generated"
private const val GENERATED_ANNOTATION = """
@Generated("com.rightpoint.inject.viewmodel.processor.ViewModelInjectProcessor")
"""
class ViewModelInjectionProcessorTest {

    @Test
    fun simple() {
        val inputViewModel = JavaFileObjects.forSourceString("test.TestViewModel", """
            package test;

            import androidx.lifecycle.ViewModel;
            import javax.inject.Inject;

            class TestViewModel extends ViewModel {

                @Inject
                TestViewModel() {}
            }
        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module(includes = ViewModelInjectionModule.class)
            abstract class TestModule {}
        """)

        val expectedModule = JavaFileObjects.forSourceString("test.ViewModelInjectionModule", """
            // Generated by @ViewModelModule. Do not modify!
            package test;

            import androidx.lifecycle.ViewModel;
            import androidx.lifecycle.ViewModelProvider;
            import com.rightpoint.inject.viewmodel.ViewModelProviderFactory;
            import com.rightpoint.inject.viewmodel.annotations.ViewModelKey;
            import dagger.Binds;
            import dagger.Module;
            import dagger.multibindings.IntoMap;
            import $GENERATED_TYPE;

            @Module
            $GENERATED_ANNOTATION
            abstract class ViewModelInjectionModule {
              private ViewModelInjectionModule() {
              }

              @Binds
              @IntoMap
              @ViewModelKey(TestViewModel.class)
              abstract ViewModel bind_test_TestViewModel(TestViewModel viewModel);

              @Binds
              abstract ViewModelProvider.Factory bindFactory(ViewModelProviderFactory factory);
            }
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule))
            .processedWith(ViewModelInjectProcessor())
            .compilesWithoutError()
            .and()
            .generatesSources(expectedModule)
    }

    @Test
    fun public() {
        val inputViewModel = JavaFileObjects.forSourceString("test.TestViewModel", """
            package test;

            import androidx.lifecycle.ViewModel;
            import javax.inject.Inject;

            class TestViewModel extends ViewModel {

                @Inject
                TestViewModel() {}
            }
        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module(includes = ViewModelInjectionModule.class)
            public abstract class TestModule {}
        """)

        val expectedModule = JavaFileObjects.forSourceString("test.ViewModelInjectionModule", """
            // Generated by @ViewModelModule. Do not modify!
            package test;

            import androidx.lifecycle.ViewModel;
            import androidx.lifecycle.ViewModelProvider;
            import com.rightpoint.inject.viewmodel.ViewModelProviderFactory;
            import com.rightpoint.inject.viewmodel.annotations.ViewModelKey;
            import dagger.Binds;
            import dagger.Module;
            import dagger.multibindings.IntoMap;
            import $GENERATED_TYPE;

            @Module
            $GENERATED_ANNOTATION
            public abstract class ViewModelInjectionModule {
              private ViewModelInjectionModule() {
              }

              @Binds
              @IntoMap
              @ViewModelKey(TestViewModel.class)
              abstract ViewModel bind_test_TestViewModel(TestViewModel viewModel);

              @Binds
              abstract ViewModelProvider.Factory bindFactory(ViewModelProviderFactory factory);
            }
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule))
            .processedWith(ViewModelInjectProcessor())
            .compilesWithoutError()
            .and()
            .generatesSources(expectedModule)
    }

    @Test
    fun androidViewModel() {
        val inputViewModel = JavaFileObjects.forSourceString("test.TestViewModel", """
            package test;

            import android.app.Application;
            import androidx.lifecycle.AndroidViewModel;
            import javax.inject.Inject;

            class TestViewModel extends AndroidViewModel {

                @Inject
                TestViewModel(Application application) {
                    super(application);
                }
            }
        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module(includes = ViewModelInjectionModule.class)
            abstract class TestModule {}
        """)

        val expectedModule = JavaFileObjects.forSourceString("test.ViewModelInjectionModule", """
            // Generated by @ViewModelModule. Do not modify!
            package test;

            import androidx.lifecycle.ViewModel;
            import androidx.lifecycle.ViewModelProvider;
            import com.rightpoint.inject.viewmodel.ViewModelProviderFactory;
            import com.rightpoint.inject.viewmodel.annotations.ViewModelKey;
            import dagger.Binds;
            import dagger.Module;
            import dagger.multibindings.IntoMap;
            import $GENERATED_TYPE;

            @Module
            $GENERATED_ANNOTATION
            abstract class ViewModelInjectionModule {
              private ViewModelInjectionModule() {
              }

              @Binds
              @IntoMap
              @ViewModelKey(TestViewModel.class)
              abstract ViewModel bind_test_TestViewModel(TestViewModel viewModel);

              @Binds
              abstract ViewModelProvider.Factory bindFactory(ViewModelProviderFactory factory);
            }
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule))
            .processedWith(ViewModelInjectProcessor())
            .compilesWithoutError()
            .and()
            .generatesSources(expectedModule)
    }

    @Test
    fun nested() {
        val inputViewModel = JavaFileObjects.forSourceString("test.Outer", """
            package test;

            import androidx.lifecycle.ViewModel;
            import javax.inject.Inject;

            class Outer {
              static class TestViewModel extends ViewModel {
                @Inject
                TestViewModel() {}
              }
            }

        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module(includes = ViewModelInjectionModule.class)
            abstract class TestModule {}
        """)

        val expectedModule = JavaFileObjects.forSourceString("test.ViewModelInjectionModule", """
            // Generated by @ViewModelModule. Do not modify!
            package test;

            import androidx.lifecycle.ViewModel;
            import androidx.lifecycle.ViewModelProvider;
            import com.rightpoint.inject.viewmodel.ViewModelProviderFactory;
            import com.rightpoint.inject.viewmodel.annotations.ViewModelKey;
            import dagger.Binds;
            import dagger.Module;
            import dagger.multibindings.IntoMap;
            import $GENERATED_TYPE;

            @Module
            $GENERATED_ANNOTATION
            abstract class ViewModelInjectionModule {
              private ViewModelInjectionModule() {
              }

              @Binds
              @IntoMap
              @ViewModelKey(Outer.TestViewModel.class)
              abstract ViewModel bind_test_Outer${'$'}TestViewModel(Outer.TestViewModel viewModel);

              @Binds
              abstract ViewModelProvider.Factory bindFactory(ViewModelProviderFactory factory);
            }
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule))
            .processedWith(ViewModelInjectProcessor())
            .compilesWithoutError()
            .and()
            .generatesSources(expectedModule)
    }

    @Test
    fun multipleModuleAnnotations() {
        val inputViewModel = JavaFileObjects.forSourceString("test.TestViewModel", """
            package test;

            import androidx.lifecycle.ViewModel;
            import javax.inject.Inject;

            class TestViewModel extends ViewModel {

                @Inject
                TestViewModel() {}
            }
        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module(includes = ViewModelInjectionModule.class)
            abstract class TestModule {}
        """)

        val extraModule = JavaFileObjects.forSourceString("test.ExtraModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module(includes = ViewModelInjectionModule.class)
            abstract class ExtraModule {}
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule, extraModule))
            .processedWith(ViewModelInjectProcessor())
            .failsToCompile()
            .withErrorContaining("Multiple @ViewModelModule-annotated modules found.")
            .`in`(inputModule)
            .onLine(9)
    }

    @Test
    fun notIncludingGeneratedModule() {
        val inputViewModel = JavaFileObjects.forSourceString("test.TestViewModel", """
            package test;

            import androidx.lifecycle.ViewModel;
            import javax.inject.Inject;

            class TestViewModel extends ViewModel {

                @Inject
                TestViewModel() {}
            }
        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module
            abstract class TestModule {}
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule))
            .processedWith(ViewModelInjectProcessor())
            .failsToCompile()
            .withErrorContaining("@ViewModelModule's @Module must include ViewModelInjectionModule")
            .`in`(inputModule)
            .onLine(9)
    }

    @Test
    fun private() {
        val inputViewModel = JavaFileObjects.forSourceString("test.TestViewModel", """
            package test;

            import androidx.lifecycle.ViewModel;
            import javax.inject.Inject;

            private class TestViewModel extends ViewModel {

                @Inject
                TestViewModel() {}
            }
        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module(includes = ViewModelInjectionModule.class)
            abstract class TestModule {}
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule))
            .processedWith(ViewModelInjectProcessor())
            .failsToCompile()
            .withErrorContaining("modifier private not allowed here")
            .`in`(inputViewModel)
            .onLine(7)

    }

    @Test
    fun nonStaticNested() {
        val inputViewModel = JavaFileObjects.forSourceString("test.Outer", """
            package test;

            import androidx.lifecycle.ViewModel;
            import javax.inject.Inject;

            class Outer {
              class TestViewModel extends ViewModel {
                @Inject
                TestViewModel() {}
              }
            }

        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module(includes = ViewModelInjectionModule.class)
            abstract class TestModule {}
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule))
            .processedWith(ViewModelInjectProcessor())
            .failsToCompile()
            .withErrorContaining("Nested @Inject-using ViewModels must be static")
            .`in`(inputViewModel)
            .onLine(8)

    }

    @Test
    fun multipleConstructors() {
        val inputViewModel = JavaFileObjects.forSourceString("test.TestViewModel", """
            package test;

            import androidx.lifecycle.ViewModel;
            import javax.inject.Inject;

            class TestViewModel extends ViewModel {

                @Inject
                TestViewModel() {}

                @Inject
                TestViewModel(Object object) {}
            }
        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module(includes = ViewModelInjectionModule.class)
            abstract class TestModule {}
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule))
            .processedWith(ViewModelInjectProcessor())
            .failsToCompile()
            .withErrorContaining("Multiple @Inject-annotated ViewModel constructors found.")
            .`in`(inputViewModel)
            .onLine(7)

    }

    @Test
    fun privateConstructor() {
        val inputViewModel = JavaFileObjects.forSourceString("test.TestViewModel", """
            package test;

            import androidx.lifecycle.ViewModel;
            import javax.inject.Inject;

            class TestViewModel extends ViewModel {

                @Inject
                private TestViewModel() {}
            }
        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;
            import dagger.Module;

            @ViewModelModule
            @Module(includes = ViewModelInjectionModule.class)
            abstract class TestModule {}
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule))
            .processedWith(ViewModelInjectProcessor())
            .failsToCompile()
            .withErrorContaining("ViewModel with @Inject constructor must not be private.")
            .`in`(inputViewModel)
            .onLine(10)

    }

    @Test
    fun nonDaggerModule() {
        val inputViewModel = JavaFileObjects.forSourceString("test.TestViewModel", """
            package test;

            import androidx.lifecycle.ViewModel;
            import javax.inject.Inject;

            class TestViewModel extends ViewModel {

                @Inject
                TestViewModel() {}
            }
        """)

        val inputModule = JavaFileObjects.forSourceString("test.TestModule", """
            package test;

            import com.rightpoint.inject.viewmodel.annotations.ViewModelModule;

            @ViewModelModule
            abstract class TestModule {}
        """)

        assertAbout(javaSources())
            .that(listOf(inputViewModel, inputModule))
            .processedWith(ViewModelInjectProcessor())
            .failsToCompile()
            .withErrorContaining("@ViewModelModule must also be annotated as a Dagger @Module")
            .`in`(inputModule)
            .onLine(7)

    }
}